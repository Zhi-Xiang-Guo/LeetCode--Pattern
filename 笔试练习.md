# 刷题

## LC - [670. 最大交换](https://leetcode.cn/problems/maximum-swap/) - 模拟

```java
class Solution {
    // 找到降序(非升序)结束后的最大值及其最大索引，并将其和降序(非升序)中小于该值的最小索引交换
    // 从 9 递减到 digits[i]+1看有没有某个数字 d > digits[i]，并且它的 last[d] 在 i 后面
    // 说明我们可以交换，让当前位变得更大 一旦找到，交换并立即返回结果（因为只允许交换一次）
    public int maximumSwap(int num) {
        char[] digits = Integer.toString(num).toCharArray();「转char」
        int n = digits.length;
        int[] last = new int[10]; // 记录每个数字最后出现的位置

        // 保证多次出现 是最后那个
        for (int i = 0; i < n; i++) {
            last[digits[i] - '0'] = i;
        }

        // 从左往右扫描每一位
        for (int i = 0; i < n; i++) {
            // 尝试从9到当前位+1寻找更大的数，交换
            for (int d = 9; d > digits[i] - '0'; d--) {
                if (last[d] > i) {
                    // 交换
                    char temp = digits[i];
                    digits[i] = digits[last[d]];
                    digits[last[d]] = temp;
                    return Integer.parseInt(new String(digits));「转Int」
                }
            }
        }

        return num;
    }
}
```

## [788. 旋转数字](https://leetcode.cn/problems/rotated-digits/) - 模拟

```java
class Solution {
    public int rotatedDigits(int n) {
        int ans = 0;
        out:for (int i = 1; i <= n; i++) {
            boolean ok = false;
            int x = i;
            while (x != 0) {
                int t = x % 10;
                x /= 10;
                // 每位数字逐个
                if (t == 2 || t == 5 || t == 6 || t == 9) ok = true;//会变（2569）- 好数
                else if (t == 3 && t == 4 && t == 7) continue out;//非有效翻转数（347）-则必然不是好数
            }
            if (ok) ans++;
        }
        return ans;
    }
}
```

## [319. 灯泡开关](https://leetcode.cn/problems/bulb-switcher/) - 数学 [672. 灯泡开关 Ⅱ](https://leetcode.cn/problems/bulb-switcher-ii/)





## [13. 罗马数字转整数](https://leetcode.cn/problems/roman-to-integer/) 、[12. 整数转罗马数字](https://leetcode.cn/problems/integer-to-roman/)

13：「S1：打表 二个优先级大」「S2hashmap存映射 、优化可用switch case

12：「S1：贪心 + 匹配」 「S2 数组范围有限 直接按每个数位 打表成数组 优化：static + sb拼接」



## 模拟 + 数学 — 最少steps to turn array into odd 

![img](assets/1752553283473-9ac70143-88f0-41be-a8da-ce0c4c0e1f30.png)

思路：全偶数 得找个一直 /2到1 最小操作那个 

有odd 其实就是合并次数 - 偶数数量

```java
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt(); // 测试用例数量

        while (t-- > 0) {
            int n = scanner.nextInt(); // 数列长度
            int[] nums = new int[n];   // 数列
            boolean hasOdd = false;    // 是否存在奇数
            int evenCount = 0;         // 偶数的数量
            int minBitLength = 32;     // 最小 bit_length（初始设为最大值）

            for (int i = 0; i < n; i++) {
                nums[i] = scanner.nextInt();
                if (nums[i] % 2 == 0) {
                    evenCount++;
                    int x = nums[i];
                    int cnt = 0;
                    // 计算 bit_length（二进制末尾的连续 0 的个数）
                    while (x % 2 == 0) {
                        cnt++;
                        x /= 2;
                    }
                    minBitLength = Math.min(minBitLength, cnt);
                } else {
                    hasOdd = true;
                }
            }

            // 分情况计算最少操作次数
            if (hasOdd) {
                System.out.println(evenCount);
            } else {
                System.out.println(evenCount + 「minBitLength - 1 steps turn into odd and 
                evenCount -1 actually);
            }
        }
        scanner.close();
    }
}
```